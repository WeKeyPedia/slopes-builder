{"query": {"pages": {"26000": {"lastrevid": 637522305, "pageid": 26000, "canonicalurl": "http://en.wikipedia.org/wiki/Ray_tracing_(graphics)", "title": "Ray tracing (graphics)", "editurl": "http://en.wikipedia.org/w/index.php?title=Ray_tracing_(graphics)&action=edit", "length": 30202, "contentmodel": "wikitext", "pagelanguage": "en", "touched": "2015-02-14T13:05:20Z", "ns": 0, "fullurl": "http://en.wikipedia.org/wiki/Ray_tracing_(graphics)", "revisions": [{"*": "<div class=\"hatnote\">Not to be confused with <a href=\"/wiki/Ray_casting\" title=\"Ray casting\">Ray casting</a>&#160;or <a href=\"/wiki/Ray_tracing_(physics)\" title=\"Ray tracing (physics)\">Ray tracing (physics)</a>.</div>\n<table class=\"metadata plainlinks ambox ambox-content ambox-Refimprove\" role=\"presentation\"><tr><td class=\"mbox-image\"><div style=\"width:52px\"><a href=\"/wiki/File:Question_book-new.svg\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png\" width=\"50\" height=\"39\" srcset=\"//upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/75px-Question_book-new.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/100px-Question_book-new.svg.png 2x\" data-file-width=\"262\" data-file-height=\"204\" /></a></div></td><td class=\"mbox-text\"><span class=\"mbox-text-span\">This article <b>needs additional citations for <a href=\"/wiki/Wikipedia:Verifiability\" title=\"Wikipedia:Verifiability\">verification</a></b>.<span class=\"hide-when-compact\"> Please help <a class=\"external text\" href=\"//en.wikipedia.org/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit\">improve this article</a> by <a href=\"/wiki/Help:Introduction_to_referencing/1\" title=\"Help:Introduction to referencing/1\">adding citations to reliable sources</a>. Unsourced material may be challenged and removed.</span>  <small><i>(March 2008)</i></small><span class=\"hide-when-compact\"></span></span></td></tr></table><div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Recursive_raytrace_of_a_sphere.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/32/Recursive_raytrace_of_a_sphere.png/250px-Recursive_raytrace_of_a_sphere.png\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/32/Recursive_raytrace_of_a_sphere.png/375px-Recursive_raytrace_of_a_sphere.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/32/Recursive_raytrace_of_a_sphere.png/500px-Recursive_raytrace_of_a_sphere.png 2x\" data-file-width=\"800\" data-file-height=\"800\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Recursive_raytrace_of_a_sphere.png\" class=\"internal\" title=\"Enlarge\"></a></div>This recursive ray tracing of a sphere demonstrates the effects of shallow <a href=\"/wiki/Depth_of_field\" title=\"Depth of field\">depth of field</a>, area light sources and <a href=\"/wiki/Diffuse_interreflection\" title=\"Diffuse interreflection\" class=\"mw-redirect\">diffuse interreflection</a>.</div></div></div>\n<p>In <a href=\"/wiki/Computer_graphics\" title=\"Computer graphics\">computer graphics</a>, <b>ray tracing</b> is a technique for generating an <a href=\"/wiki/Digital_image\" title=\"Digital image\">image</a> by tracing the path of <a href=\"/wiki/Light\" title=\"Light\">light</a> through <a href=\"/wiki/Pixel\" title=\"Pixel\">pixels</a> in an <a href=\"/wiki/Image_plane\" title=\"Image plane\">image plane</a> and simulating the effects of its encounters with virtual objects.  The technique is capable of producing a very high degree of visual realism, usually higher than that of typical <a href=\"/wiki/Scanline_rendering\" title=\"Scanline rendering\">scanline rendering</a> methods, but at a greater <a href=\"/wiki/Computation_time\" title=\"Computation time\" class=\"mw-redirect\">computational cost</a>. This makes ray tracing best suited for applications where the image can be rendered slowly ahead of time, such as in still images and film and television <a href=\"/wiki/Visual_effects\" title=\"Visual effects\">visual effects</a>, and more poorly suited for real-time applications like <a href=\"/wiki/Video_game\" title=\"Video game\">video games</a> where speed is critical. Ray tracing is capable of simulating a wide variety of optical effects, such as <a href=\"/wiki/Reflection_(physics)\" title=\"Reflection (physics)\">reflection</a> and <a href=\"/wiki/Refraction\" title=\"Refraction\">refraction</a>, <a href=\"/wiki/Light_scattering\" title=\"Light scattering\">scattering</a>, and <a href=\"/wiki/Dispersion_(optics)\" title=\"Dispersion (optics)\">dispersion</a> phenomena (such as <a href=\"/wiki/Chromatic_aberration\" title=\"Chromatic aberration\">chromatic aberration</a>).\n</p>\n<div id=\"toc\" class=\"toc\"><div id=\"toctitle\"><h2>Contents</h2></div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Algorithm_overview\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Algorithm overview</span></a></li>\n<li class=\"toclevel-1 tocsection-2\"><a href=\"#Detailed_description_of_ray_tracing_computer_algorithm_and_its_genesis\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Detailed description of ray tracing computer algorithm and its genesis</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-3\"><a href=\"#What_happens_in_nature\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">What happens in nature</span></a></li>\n<li class=\"toclevel-2 tocsection-4\"><a href=\"#Ray_casting_algorithm\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Ray casting algorithm</span></a></li>\n<li class=\"toclevel-2 tocsection-5\"><a href=\"#Recursive_ray_tracing_algorithm\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Recursive ray tracing algorithm</span></a></li>\n<li class=\"toclevel-2 tocsection-6\"><a href=\"#Advantages_over_other_rendering_methods\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Advantages over other rendering methods</span></a></li>\n<li class=\"toclevel-2 tocsection-7\"><a href=\"#Disadvantages\"><span class=\"tocnumber\">2.5</span> <span class=\"toctext\">Disadvantages</span></a></li>\n<li class=\"toclevel-2 tocsection-8\"><a href=\"#Reversed_direction_of_traversal_of_scene_by_the_rays\"><span class=\"tocnumber\">2.6</span> <span class=\"toctext\">Reversed direction of traversal of scene by the rays</span></a></li>\n<li class=\"toclevel-2 tocsection-9\"><a href=\"#Example\"><span class=\"tocnumber\">2.7</span> <span class=\"toctext\">Example</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-10\"><a href=\"#Adaptive_depth_control\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">Adaptive depth control</span></a></li>\n<li class=\"toclevel-1 tocsection-11\"><a href=\"#Bounding_volumes\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">Bounding volumes</span></a></li>\n<li class=\"toclevel-1 tocsection-12\"><a href=\"#In_real_time\"><span class=\"tocnumber\">5</span> <span class=\"toctext\">In real time</span></a></li>\n<li class=\"toclevel-1 tocsection-13\"><a href=\"#Computational_Complexity\"><span class=\"tocnumber\">6</span> <span class=\"toctext\">Computational Complexity</span></a></li>\n<li class=\"toclevel-1 tocsection-14\"><a href=\"#See_also\"><span class=\"tocnumber\">7</span> <span class=\"toctext\">See also</span></a></li>\n<li class=\"toclevel-1 tocsection-15\"><a href=\"#References\"><span class=\"tocnumber\">8</span> <span class=\"toctext\">References</span></a></li>\n<li class=\"toclevel-1 tocsection-16\"><a href=\"#External_links\"><span class=\"tocnumber\">9</span> <span class=\"toctext\">External links</span></a></li>\n</ul>\n</div>\n\n<h2><span class=\"mw-headline\" id=\"Algorithm_overview\">Algorithm overview</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=1\" title=\"Edit section: Algorithm overview\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:302px;\"><a href=\"/wiki/File:Ray_trace_diagram.svg\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/8/83/Ray_trace_diagram.svg/300px-Ray_trace_diagram.svg.png\" width=\"300\" height=\"200\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/8/83/Ray_trace_diagram.svg/450px-Ray_trace_diagram.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/8/83/Ray_trace_diagram.svg/600px-Ray_trace_diagram.svg.png 2x\" data-file-width=\"875\" data-file-height=\"582\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Ray_trace_diagram.svg\" class=\"internal\" title=\"Enlarge\"></a></div>The ray tracing algorithm builds an image by extending rays into a scene.</div></div></div>\n<p>Optical ray tracing describes a method for producing visual images constructed in <a href=\"/wiki/3D_computer_graphics\" title=\"3D computer graphics\">3D computer graphics</a> environments, with more photorealism than either <a href=\"/wiki/Ray_casting\" title=\"Ray casting\">ray casting</a> or <a href=\"/wiki/Scanline_rendering\" title=\"Scanline rendering\">scanline rendering</a> techniques. It works by tracing a path from an imaginary eye through each <a href=\"/wiki/Pixel\" title=\"Pixel\">pixel</a> in a virtual screen, and calculating the color of the object visible through it.\n</p><p>Scenes in ray tracing are described mathematically by a programmer or by a visual artist (typically using intermediary tools). Scenes may also incorporate data from images and models captured by means such as digital photography.\n</p><p>Typically, each ray must be tested for intersection with some subset of all the objects in the scene. Once the nearest object has been identified, the algorithm will estimate the incoming <a href=\"/wiki/Computer_graphics_lighting\" title=\"Computer graphics lighting\">light</a> at the point of intersection, examine the material properties of the object, and combine this information to calculate the final color of the pixel. Certain illumination algorithms and reflective or translucent materials may require more rays to be re-cast into the scene.\n</p><p>It may at first seem counterintuitive or \"backwards\" to send rays <i>away</i> from the camera, rather than <i>into</i> it (as actual light does in reality), but doing so is many orders of magnitude more efficient. Since the overwhelming majority of light rays from a given light source do not make it directly into the viewer's eye, a \"forward\" simulation could potentially waste a tremendous amount of computation on light paths that are never recorded.\n</p><p>Therefore, the shortcut taken in raytracing is to presuppose that a given ray intersects the view frame. After either a maximum number of reflections or a ray traveling a certain distance without intersection, the ray ceases to travel and the pixel's value is updated.\n<br style=\"clear:both;\"/>\n</p>\n<h2><span class=\"mw-headline\" id=\"Detailed_description_of_ray_tracing_computer_algorithm_and_its_genesis\">Detailed description of ray tracing computer algorithm and its genesis</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=2\" title=\"Edit section: Detailed description of ray tracing computer algorithm and its genesis\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<h3><span class=\"mw-headline\" id=\"What_happens_in_nature\">What happens in nature</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=3\" title=\"Edit section: What happens in nature\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>In nature, a light source emits a ray of light which travels, eventually, to a surface that interrupts its progress.  One can think of this \"ray\" as a stream of <a href=\"/wiki/Photon\" title=\"Photon\">photons</a> traveling along the same path.  In a perfect vacuum this ray will be a straight line (ignoring <a href=\"/wiki/General_relativity\" title=\"General relativity\">relativistic effects</a>). Any combination of four things might happen with this light ray:  <a href=\"/wiki/Absorption_(electromagnetic_radiation)\" title=\"Absorption (electromagnetic radiation)\">absorption</a>, <a href=\"/wiki/Reflection_(physics)\" title=\"Reflection (physics)\">reflection</a>, <a href=\"/wiki/Refraction\" title=\"Refraction\">refraction</a> and <a href=\"/wiki/Fluorescence\" title=\"Fluorescence\">fluorescence</a>.  A surface may absorb part of the light ray, resulting in a loss of intensity of the reflected and/or refracted light.  It might also reflect all or part of the light ray, in one or more directions. If the surface has any <a href=\"/wiki/Transparency_(optics)\" title=\"Transparency (optics)\" class=\"mw-redirect\">transparent</a> or <a href=\"/wiki/Transparency_(optics)\" title=\"Transparency (optics)\" class=\"mw-redirect\">translucent</a> properties, it refracts a portion of the light beam into itself in a different direction while absorbing some (or all) of the <a href=\"/wiki/Visible_spectrum\" title=\"Visible spectrum\">spectrum</a> (and possibly altering the color). Less commonly, a surface may absorb some portion of the light and fluorescently re-emit the light at a longer wavelength colour in a random direction, though this is rare enough that it can be discounted from most rendering applications. Between absorption, reflection, refraction and fluorescence, all of the incoming light must be accounted for, and no more.  A surface cannot, for instance, reflect 66% of an incoming light ray, and refract 50%, since the two would add up to be 116%. From here, the reflected and/or refracted rays may strike other surfaces, where their absorptive, refractive, reflective and fluorescent properties again affect the progress of  the incoming rays.  Some of these rays travel in such a way that they hit our eye, causing us to see the scene and so contribute to the final rendered image.\n</p>\n<h3><span class=\"mw-headline\" id=\"Ray_casting_algorithm\">Ray casting algorithm</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=4\" title=\"Edit section: Ray casting algorithm\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"hatnote relarticle mainarticle\">Main article: <a href=\"/wiki/Ray_casting\" title=\"Ray casting\">Ray casting</a></div>\n<p>The first ray tracing algorithm used for rendering was presented by <a href=\"/w/index.php?title=Arthur_Appel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Arthur Appel (page does not exist)\">Arthur Appel</a><sup id=\"cite_ref-1\" class=\"reference\"><a href=\"#cite_note-1\"><span>[</span>1<span>]</span></a></sup> in 1968. This algorithm has since been termed \"ray casting\". The idea behind ray casting is to shoot rays from the eye, one per pixel, and find the closest object blocking the path of that ray. Think of an image as a screen-door, with each square in the screen being a pixel.  This is then the object the eye sees through that pixel.  Using the material properties and the effect of the lights in the scene, this algorithm can determine the <a href=\"/wiki/Shading\" title=\"Shading\">shading</a> of this object.  The simplifying assumption is made that if a surface faces a light, the light will reach that surface and not be blocked or in shadow.  The shading of the surface is computed using traditional 3D computer graphics shading models.  One important advantage ray casting offered over older <a href=\"/wiki/Scanline_rendering\" title=\"Scanline rendering\">scanline algorithms</a> was its ability to easily deal with non-planar surfaces and solids, such as <a href=\"/wiki/Cone_(geometry)\" title=\"Cone (geometry)\" class=\"mw-redirect\">cones</a> and <a href=\"/wiki/Sphere\" title=\"Sphere\">spheres</a>. If a mathematical surface can be intersected by a ray, it can be rendered using ray casting. Elaborate objects can be created by using <a href=\"/wiki/Solid_modeling\" title=\"Solid modeling\">solid modeling</a> techniques and easily rendered.\n</p>\n<h3><span class=\"mw-headline\" id=\"Recursive_ray_tracing_algorithm\">Recursive ray tracing algorithm</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=5\" title=\"Edit section: Recursive ray tracing algorithm\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:302px;\"><a href=\"/wiki/File:Glasses_800_edit.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Glasses_800_edit.png/300px-Glasses_800_edit.png\" width=\"300\" height=\"225\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Glasses_800_edit.png/450px-Glasses_800_edit.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Glasses_800_edit.png/600px-Glasses_800_edit.png 2x\" data-file-width=\"2048\" data-file-height=\"1536\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Glasses_800_edit.png\" class=\"internal\" title=\"Enlarge\"></a></div>Ray tracing can create realistic images.</div></div></div>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:302px;\"><a href=\"/wiki/File:BallsRender.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/ae/BallsRender.png/300px-BallsRender.png\" width=\"300\" height=\"169\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/ae/BallsRender.png/450px-BallsRender.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/ae/BallsRender.png/600px-BallsRender.png 2x\" data-file-width=\"1920\" data-file-height=\"1080\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:BallsRender.png\" class=\"internal\" title=\"Enlarge\"></a></div>In addition to the high degree of realism, ray tracing can simulate the effects of a camera due to <a href=\"/wiki/Depth_of_field\" title=\"Depth of field\">depth of field</a> and <a href=\"/wiki/Aperture\" title=\"Aperture\">aperture</a> shape (in this case a <a href=\"/wiki/Hexagon\" title=\"Hexagon\">hexagon</a>).</div></div></div>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:302px;\"><a href=\"/wiki/File:Ray-traced_steel_balls.jpg\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/36/Ray-traced_steel_balls.jpg/300px-Ray-traced_steel_balls.jpg\" width=\"300\" height=\"225\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/36/Ray-traced_steel_balls.jpg/450px-Ray-traced_steel_balls.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/36/Ray-traced_steel_balls.jpg/600px-Ray-traced_steel_balls.jpg 2x\" data-file-width=\"1600\" data-file-height=\"1200\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Ray-traced_steel_balls.jpg\" class=\"internal\" title=\"Enlarge\"></a></div>The number of reflections a \u201cray\u201d can take and how it is affected each time it encounters a surface is all controlled via software settings during ray tracing. Here, each ray was allowed to reflect up to 16 times. Multiple \u201creflections of reflections\u201d can thus be seen. <i>Created with <a href=\"/wiki/Cobalt_(CAD_program)\" title=\"Cobalt (CAD program)\">Cobalt</a></i></div></div></div>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:302px;\"><a href=\"/wiki/File:Glass_ochem.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/40/Glass_ochem.png/300px-Glass_ochem.png\" width=\"300\" height=\"150\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/40/Glass_ochem.png/450px-Glass_ochem.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/40/Glass_ochem.png/600px-Glass_ochem.png 2x\" data-file-width=\"2880\" data-file-height=\"1440\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Glass_ochem.png\" class=\"internal\" title=\"Enlarge\"></a></div>The number of <a href=\"/wiki/Refraction\" title=\"Refraction\">refractions</a> a \u201cray\u201d can take and how it is affected each time it encounters a surface is all controlled via software settings during ray tracing. Here, each ray was allowed to refract and reflect up to 9 times. <a href=\"/wiki/Fresnel_reflection\" title=\"Fresnel reflection\" class=\"mw-redirect\">Fresnel reflections</a> were used. Also note the <a href=\"/wiki/Caustic_(optics)\" title=\"Caustic (optics)\">caustics</a>. <i>Created with <a href=\"/wiki/Vray\" title=\"Vray\" class=\"mw-redirect\">Vray</a></i></div></div></div>\n<p>The next important research breakthrough came from <a href=\"/wiki/Turner_Whitted\" title=\"Turner Whitted\" class=\"mw-redirect\">Turner Whitted</a> in 1979.<sup id=\"cite_ref-2\" class=\"reference\"><a href=\"#cite_note-2\"><span>[</span>2<span>]</span></a></sup> Previous algorithms traced rays from the eye into the scene until they hit an object, but determined the ray color without recursively tracing more rays.  Whitted continued the process.  When a ray hits a surface, it can generate up to three new types of rays: reflection, refraction, and shadow.<sup id=\"cite_ref-3\" class=\"reference\"><a href=\"#cite_note-3\"><span>[</span>3<span>]</span></a></sup> A reflection ray is traced in the mirror-reflection direction. The closest object it intersects is what will be seen in the reflection.  Refraction rays traveling through transparent material work similarly, with the addition that a refractive ray could be entering or exiting a material.  A shadow ray is traced toward each light. If any opaque object is found between the surface and the light, the surface is in shadow and the light does not illuminate it.  This recursive ray tracing added more realism to ray traced images.\n</p>\n<h3><span class=\"mw-headline\" id=\"Advantages_over_other_rendering_methods\">Advantages over other rendering methods</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=6\" title=\"Edit section: Advantages over other rendering methods\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>Ray tracing's popularity stems from its basis in a realistic simulation of <a href=\"/wiki/Computer_graphics_lighting\" title=\"Computer graphics lighting\">lighting</a> over other rendering methods (such as scanline rendering or ray casting).  Effects such as reflections and <a href=\"/wiki/Shadow\" title=\"Shadow\">shadows</a>, which are difficult to simulate using other algorithms, are a natural result of the ray tracing algorithm. The computational independence of each ray makes ray tracing amenable to <a href=\"/wiki/Parallelization\" title=\"Parallelization\" class=\"mw-redirect\">parallelization</a>.<sup id=\"cite_ref-4\" class=\"reference\"><a href=\"#cite_note-4\"><span>[</span>4<span>]</span></a></sup><sup id=\"cite_ref-5\" class=\"reference\"><a href=\"#cite_note-5\"><span>[</span>5<span>]</span></a></sup>\n</p>\n<h3><span class=\"mw-headline\" id=\"Disadvantages\">Disadvantages</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=7\" title=\"Edit section: Disadvantages\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>A serious disadvantage of ray tracing is performance. Scanline algorithms and other algorithms use data coherence to share computations between pixels, while ray tracing normally starts the process anew, treating each eye ray separately. However, this separation offers other advantages, such as the ability to shoot more rays as needed to perform <a href=\"/wiki/Spatial_anti-aliasing\" title=\"Spatial anti-aliasing\">spatial anti-aliasing</a> and improve image quality where needed.\n</p><p>Although it does handle interreflection and optical effects such as refraction accurately, traditional ray tracing is also not necessarily photorealistic. True photorealism occurs when the <a href=\"/wiki/Rendering_equation\" title=\"Rendering equation\">rendering equation</a> is closely approximated or fully implemented. Implementing the rendering equation gives true photorealism, as the equation describes every physical effect of light flow. However, this is usually infeasible given the computing resources required.\n</p><p>The realism of all rendering methods can be evaluated as an approximation to the equation. Ray tracing, if it is limited to Whitted's algorithm, is not necessarily the most realistic. Methods that trace rays, but include additional techniques (<a href=\"/wiki/Photon_mapping\" title=\"Photon mapping\">photon mapping</a>, <a href=\"/wiki/Path_tracing\" title=\"Path tracing\">path tracing</a>), give far more accurate simulation of real-world lighting.\n</p><p>It is also possible to approximate the equation using ray casting in a different way than what is traditionally considered to be \"ray tracing\". For performance, rays can be clustered according to their direction, with rasterization hardware and depth peeling used to efficiently sum the rays.<sup id=\"cite_ref-6\" class=\"reference\"><a href=\"#cite_note-6\"><span>[</span>6<span>]</span></a></sup>\n</p>\n<h3><span class=\"mw-headline\" id=\"Reversed_direction_of_traversal_of_scene_by_the_rays\">Reversed direction of traversal of scene by the rays</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=8\" title=\"Edit section: Reversed direction of traversal of scene by the rays\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>The process of shooting rays from the eye to the light source to render an image is sometimes called <i>backwards ray tracing</i>, since it is the opposite direction photons actually travel. However, there is confusion with this terminology. Early ray tracing was always done from the eye, and early researchers such as <a href=\"/w/index.php?title=James_Arvo&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"James Arvo (page does not exist)\">James Arvo</a> used the term <i>backwards ray tracing</i> to mean shooting rays from the lights and gathering the results.  Therefore it is clearer to distinguish <i>eye-based</i> versus <i>light-based</i> ray tracing.\n</p><p>While the direct illumination is generally best sampled using eye-based ray tracing, certain indirect effects can benefit from rays generated from the lights. <a href=\"/wiki/Caustic_(optics)\" title=\"Caustic (optics)\">Caustics</a> are bright patterns caused by the focusing of light off a wide reflective region onto a narrow area of (near-)diffuse surface.  An algorithm that casts rays directly from lights onto reflective objects, tracing their paths to the eye, will better sample this phenomenon. This integration of eye-based and light-based rays is often expressed as bidirectional path tracing, in which paths are traced from both the eye and lights, and the paths subsequently joined by a connecting ray after some length.<sup id=\"cite_ref-7\" class=\"reference\"><a href=\"#cite_note-7\"><span>[</span>7<span>]</span></a></sup><sup id=\"cite_ref-8\" class=\"reference\"><a href=\"#cite_note-8\"><span>[</span>8<span>]</span></a></sup>\n</p><p><a href=\"/wiki/Photon_mapping\" title=\"Photon mapping\">Photon mapping</a> is another method that uses both light-based and eye-based ray tracing; in an initial pass, energetic photons are traced along rays from the light source so as to compute an estimate of radiant flux as a function of 3-dimensional space (the eponymous photon map itself). In a subsequent pass, rays are traced from the eye into the scene to determine the visible surfaces, and the photon map is used to estimate the illumination at the visible surface points.<sup id=\"cite_ref-9\" class=\"reference\"><a href=\"#cite_note-9\"><span>[</span>9<span>]</span></a></sup><sup id=\"cite_ref-10\" class=\"reference\"><a href=\"#cite_note-10\"><span>[</span>10<span>]</span></a></sup> The advantage of photon mapping versus bidirectional path tracing is the ability to achieve significant reuse of photons, reducing computation, at the cost of statistical bias.\n</p><p>An additional problem occurs when light must pass through a very narrow aperture to illuminate the scene (consider a darkened room, with a door slightly ajar leading to a brightly lit room), or a scene in which most points do not have direct line-of-sight to any light source (such as with ceiling-directed light fixtures or <a href=\"/wiki/Torchiere\" title=\"Torchiere\" class=\"mw-redirect\">torchieres</a>). In such cases, only a very small subset of paths will transport energy; <a href=\"/wiki/Metropolis_light_transport\" title=\"Metropolis light transport\">Metropolis light transport</a> is a method which begins with a random search of the path space, and when energetic paths are found, reuses this information by exploring the nearby space of rays.<sup id=\"cite_ref-11\" class=\"reference\"><a href=\"#cite_note-11\"><span>[</span>11<span>]</span></a></sup>\n</p>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:222px;\"><a href=\"/wiki/File:PathOfRays.svg\" class=\"image\"><img alt=\"PathOfRays.svg\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/1/16/PathOfRays.svg/220px-PathOfRays.svg.png\" width=\"220\" height=\"143\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/1/16/PathOfRays.svg/330px-PathOfRays.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/16/PathOfRays.svg/440px-PathOfRays.svg.png 2x\" data-file-width=\"402\" data-file-height=\"261\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:PathOfRays.svg\" class=\"internal\" title=\"Enlarge\"></a></div></div></div></div>\n<p>To the right is an image showing a simple example of a path of rays recursively generated from the camera (or eye) to the light source using the above algorithm. A diffuse surface reflects light in all directions.\n</p><p>First, a ray is created at an eyepoint and traced through a pixel and into the scene, where it hits a diffuse surface. From that surface the algorithm recursively generates a reflection ray, which is traced through the scene, where it hits another diffuse surface. Finally, another reflection ray is generated and traced through the scene, where it hits the light source and is absorbed. The color of the pixel now depends on the colors of the first and second diffuse surface and the color of the light emitted from the light source. For example if the light source emitted white light and the two diffuse surfaces were blue, then the resulting color of the pixel is blue.\n</p>\n<h3><span class=\"mw-headline\" id=\"Example\">Example</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=9\" title=\"Edit section: Example\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<table class=\"metadata plainlinks ambox mbox-small-left ambox-style\" role=\"presentation\"><tr><td class=\"mbox-image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/20px-Edit-clear.svg.png\" width=\"20\" height=\"20\" srcset=\"//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/30px-Edit-clear.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png 2x\" data-file-width=\"48\" data-file-height=\"48\" /></td><td class=\"mbox-text\"><span class=\"mbox-text-span\">This section <b><a href=\"/wiki/Wikipedia:CFORK\" title=\"Wikipedia:CFORK\" class=\"mw-redirect\">duplicates</a>, in whole or part, the scope of other sections</b>, specifically, <a href=\"/wiki/Line%E2%80%93sphere_intersection\" title=\"Line\u2013sphere intersection\">Line\u2013sphere intersection</a>.  <small><i>(May 2014)</i></small></span></td></tr></table>\n<p>As a demonstration of the principles involved in raytracing, let us consider how one would find the intersection between a ray and a sphere. This is merely the math behind the <a href=\"/wiki/Line%E2%80%93sphere_intersection\" title=\"Line\u2013sphere intersection\">line\u2013sphere intersection</a> and the subsequent determination of the colour of the pixel being calculated. There is, of course, far more to the general process of raytracing, but this demonstrates an example of the algorithms used.\n</p><p>In <a href=\"/wiki/Vector_notation\" title=\"Vector notation\">vector notation</a>, the equation of a sphere with center <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf c\" src=\"//upload.wikimedia.org/math/c/9/a/c9a972007073f0910c7cfb51b859bed9.png\" /> and radius <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf r\" src=\"//upload.wikimedia.org/math/d/1/1/d11b02d2496069c6daadd761595967b5.png\" /> is\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\left\\Vert \\mathbf x - \\mathbf c \\right\\Vert^2=r^2.\" src=\"//upload.wikimedia.org/math/4/5/c/45c1aeaf4b80745afefc078c67685c62.png\" /></dd></dl>\n<p>Any point on a ray starting from point <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf s\" src=\"//upload.wikimedia.org/math/1/7/a/17a7f439a09c58cee926a2420aed0447.png\" /> with direction <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf d\" src=\"//upload.wikimedia.org/math/e/2/2/e22d2980e688655b7a4f720c34bf5855.png\" /> (here <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf d\" src=\"//upload.wikimedia.org/math/e/2/2/e22d2980e688655b7a4f720c34bf5855.png\" /> is a <a href=\"/wiki/Unit_vector\" title=\"Unit vector\">unit vector</a>) can be written as\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf x=\\mathbf s+t\\mathbf d,\" src=\"//upload.wikimedia.org/math/3/1/7/317b595572ee2b8cba470bc23f97e3c0.png\" /></dd></dl>\n<p>where <img class=\"mwe-math-fallback-image-inline tex\" alt=\" t\" src=\"//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png\" /> is its distance between <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf x\" src=\"//upload.wikimedia.org/math/9/b/1/9b15a163160465cf38245ff82c459ea0.png\" /> and <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf s\" src=\"//upload.wikimedia.org/math/1/7/a/17a7f439a09c58cee926a2420aed0447.png\" />.  In our problem, we know <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf c\" src=\"//upload.wikimedia.org/math/c/9/a/c9a972007073f0910c7cfb51b859bed9.png\" />,  <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf r\" src=\"//upload.wikimedia.org/math/d/1/1/d11b02d2496069c6daadd761595967b5.png\" />, <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf s\" src=\"//upload.wikimedia.org/math/1/7/a/17a7f439a09c58cee926a2420aed0447.png\" /> (e.g. the position of a light source) and <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf d\" src=\"//upload.wikimedia.org/math/e/2/2/e22d2980e688655b7a4f720c34bf5855.png\" />, and we need to find <img class=\"mwe-math-fallback-image-inline tex\" alt=\" t\" src=\"//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png\" />. Therefore, we substitute for <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf x\" src=\"//upload.wikimedia.org/math/9/b/1/9b15a163160465cf38245ff82c459ea0.png\" />:\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\left\\Vert\\mathbf{s}+t\\mathbf{d}-\\mathbf{c}\\right\\Vert^{2}=r^2.\" src=\"//upload.wikimedia.org/math/1/9/d/19db5331cb416acd27e633a844418cbe.png\" /></dd></dl>\n<p>Let <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf{v}\\ \\stackrel{\\mathrm{def}}{=}\\  \\mathbf{s}-\\mathbf{c}\" src=\"//upload.wikimedia.org/math/1/e/3/1e328cef6d853f1d19fd8f10260c3e05.png\" /> for simplicity; then\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\left\\Vert\\mathbf{v}+t\\mathbf{d}\\right\\Vert^{2}=r^{2}\" src=\"//upload.wikimedia.org/math/f/5/5/f5543b73b7d96daf6b25768305d0a2df.png\" /></dd></dl>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf{v}^2+t^2\\mathbf{d}^2+2\\mathbf{v}\\cdot t\\mathbf{d}=r^2\" src=\"//upload.wikimedia.org/math/0/c/2/0c2869c400d85ce6a427c10619b8cc1c.png\" /></dd></dl>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"(\\mathbf{d}^2)t^2+(2\\mathbf{v}\\cdot\\mathbf{d})t+(\\mathbf{v}^2-r^2)=0.\" src=\"//upload.wikimedia.org/math/d/a/3/da36573a72368d46482b8654889afbc9.png\" /></dd></dl>\n<p>Knowing that d is a unit vector allows us this minor simplification:\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"t^2+(2\\mathbf{v}\\cdot\\mathbf{d})t+(\\mathbf{v}^2-r^2)=0.\" src=\"//upload.wikimedia.org/math/6/b/d/6bd87d1d3d01d01e4a34cf6730a7e478.png\" /></dd></dl>\n<p>This <a href=\"/wiki/Quadratic_equation\" title=\"Quadratic equation\">quadratic equation</a> has solutions\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"t=\\frac{-(2\\mathbf{v}\\cdot\\mathbf{d})\\pm\\sqrt{(2\\mathbf{v}\\cdot\\mathbf{d})^2-4(\\mathbf{v}^2-r^2)}}{2}=-(\\mathbf{v}\\cdot\\mathbf{d})\\pm\\sqrt{(\\mathbf{v}\\cdot\\mathbf{d})^2-(\\mathbf{v}^2-r^2)}.\" src=\"//upload.wikimedia.org/math/9/d/6/9d62d39e5a918e2484475d9954d8f71d.png\" /></dd></dl>\n<p>The two values of <img class=\"mwe-math-fallback-image-inline tex\" alt=\"t\" src=\"//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png\" /> found by solving this equation are the two ones such that <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf s+t\\mathbf d\" src=\"//upload.wikimedia.org/math/c/b/8/cb865003475d27c58d8efef35c6f7ea9.png\" /> are the points where the ray intersects the sphere.\n</p><p>Any value which is negative does not lie on the ray, but rather in the opposite <a href=\"/wiki/Line_(mathematics)\" title=\"Line (mathematics)\" class=\"mw-redirect\">half-line</a> (i.e. the one starting from <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf s\" src=\"//upload.wikimedia.org/math/1/7/a/17a7f439a09c58cee926a2420aed0447.png\" /> with opposite direction).\n</p><p>If the quantity under the square root ( the <a href=\"/wiki/Quadratic_equation#Discriminant\" title=\"Quadratic equation\">discriminant</a> )  is negative, then the ray does not intersect the sphere.\n</p><p>Let us suppose now that there is at least a positive solution, and let <img class=\"mwe-math-fallback-image-inline tex\" alt=\"t\" src=\"//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png\" /> be the minimal one. In addition, let us suppose that the sphere is the nearest object on our scene intersecting our ray, and that it is made of a reflective material. We need to find in which direction the light ray is reflected. The laws of <a href=\"/wiki/Reflection_(physics)\" title=\"Reflection (physics)\">reflection</a> state that the angle of reflection is equal and opposite to the angle of incidence between the incident ray and the <a href=\"/wiki/Surface_normal\" title=\"Surface normal\" class=\"mw-redirect\">normal</a> to the sphere.\n</p><p>The normal to the sphere is simply\n</p>\n<dl><dd><img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf n=\\frac{\\mathbf y- \\mathbf c}{\\left\\Vert\\mathbf y- \\mathbf c\\right\\Vert},\" src=\"//upload.wikimedia.org/math/2/2/3/223f82bf768ed1a35258ad3bab099483.png\" /></dd></dl>\n<p>where <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf y=\\mathbf s+t\\mathbf d\" src=\"//upload.wikimedia.org/math/4/3/e/43e159fdce9e4aa2d22cfc8c23804030.png\" /> is the intersection point found before. The reflection direction can be found by a <a href=\"/wiki/Reflection_(mathematics)\" title=\"Reflection (mathematics)\">reflection</a> of <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf d\" src=\"//upload.wikimedia.org/math/e/2/2/e22d2980e688655b7a4f720c34bf5855.png\" /> with respect to <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf n\" src=\"//upload.wikimedia.org/math/5/9/6/59652de65db12a695fb27fb1608aef30.png\" />, that is\n</p>\n<dl><dd> <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf r = \\mathbf d - 2(\\mathbf n \\cdot \\mathbf d ) \\mathbf n.\" src=\"//upload.wikimedia.org/math/b/9/2/b92ed2a9887167f024d903da18a80510.png\" /></dd></dl>\n<p>Thus the reflected ray has equation\n</p>\n<dl><dd> <img class=\"mwe-math-fallback-image-inline tex\" alt=\"\\mathbf x = \\mathbf y  + u \\mathbf r. \\, \" src=\"//upload.wikimedia.org/math/2/9/5/295432cce3a42e35d986ed3d26c61de6.png\" /></dd></dl>\n<p>Now we only need to compute the intersection of the latter ray with our <a href=\"/wiki/Field_of_view\" title=\"Field of view\">field of view</a>, to get the pixel which our reflected light ray will hit. Lastly, this pixel is set to an appropriate color, taking into account how the color of the original light source and the one of the sphere are combined by the reflection.\n</p>\n<h2><span class=\"mw-headline\" id=\"Adaptive_depth_control\">Adaptive depth control</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=10\" title=\"Edit section: Adaptive depth control\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>This means that we stop generating reflected/transmitted rays when the computed intensity becomes less than a certain threshold. You must always set a certain maximum depth or else the program would generate an infinite number of rays. But it is not always necessary to go to the maximum depth if the surfaces are not highly reflective. To test for this the ray tracer must compute and keep the product of the global and reflection coefficients as the rays are traced.\n</p><p>Example: let Kr = 0.5 for a set of surfaces. Then from the first surface the maximum contribution is 0.5, for the reflection from the second: 0.5 * 0.5 = 0.25, the third: 0.25 * 0.5 = 0.125, the fourth: 0.125 * 0.5 = 0.0625, the fifth: 0.0625 * 0.5 = 0.03125, etc. In addition we might implement a distance attenuation factor such as 1/D2, which would also decrease the intensity contribution.\n</p><p>For a transmitted ray we could do something similar but in that case the distance traveled through the object would cause even faster intensity decrease. As an example of this, Hall &amp; Greenberg<sup class=\"noprint Inline-Template Template-Fact\" style=\"white-space:nowrap;\">&#91;<i><a href=\"/wiki/Wikipedia:Citation_needed\" title=\"Wikipedia:Citation needed\"><span title=\"This claim needs references to reliable sources. (May 2013)\">citation needed</span></a></i>&#93;</sup>found that even for a very reflective scene, using this with a maximum depth of 15 resulted in an average ray tree depth of 1.7.\n</p>\n<h2><span class=\"mw-headline\" id=\"Bounding_volumes\">Bounding volumes</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=11\" title=\"Edit section: Bounding volumes\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>We enclose groups of objects in sets of <a href=\"/wiki/Bounding_volume_hierarchy\" title=\"Bounding volume hierarchy\">hierarchical bounding volumes</a> and first test for intersection with the <a href=\"/wiki/Bounding_volume\" title=\"Bounding volume\">bounding volume</a>, and then only if there is an intersection, against the objects enclosed by the volume.\n</p><p>Bounding volumes should be easy to test for intersection, for example a sphere or box (slab). The best bounding volume will be determined by the shape of the underlying object or objects. For example, if the objects are long and thin then a sphere will enclose mainly empty space and a box is much better. Boxes are also easier for hierarchical bounding volumes.\n</p><p>Note that using a hierarchical system like this (assuming it is done carefully) changes the intersection computational time from a linear dependence on the number of objects to something between linear and a logarithmic dependence. This is because, for a perfect case, each intersection test would divide the possibilities by two, and we would have a binary tree type structure. Spatial subdivision methods, discussed below, try to achieve this.\n</p><p>Kay &amp; Kajiya give a list of desired properties for hierarchical bounding volumes:\n</p>\n<ul><li> Subtrees should contain objects that are near each other and the further down the tree the closer should be the objects.</li>\n<li> The volume of each node should be minimal.</li>\n<li> The sum of the volumes of all bounding volumes should be minimal.</li>\n<li> Greater attention should be placed on the nodes near the root since pruning a branch near the root will remove more potential objects than one farther down the tree.</li>\n<li> The time spent constructing the hierarchy should be much less than the time saved by using it.</li></ul>\n<h2><span class=\"mw-headline\" id=\"In_real_time\">In real time</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=12\" title=\"Edit section: In real time\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>The first implementation of a \"real-time\" ray-tracer was credited at the 2005 <a href=\"/wiki/SIGGRAPH\" title=\"SIGGRAPH\">SIGGRAPH</a> computer graphics conference as the REMRT/RT tools developed in 1986 by <a href=\"/wiki/Mike_Muuss\" title=\"Mike Muuss\">Mike Muuss</a> for the <a href=\"/wiki/BRL-CAD\" title=\"BRL-CAD\">BRL-CAD</a> solid modeling system.  Initially published in 1987 at <a href=\"/wiki/USENIX\" title=\"USENIX\">USENIX</a>, the BRL-CAD ray-tracer is the first known implementation of a parallel network distributed ray-tracing system that achieved several frames per second in rendering performance.<sup id=\"cite_ref-12\" class=\"reference\"><a href=\"#cite_note-12\"><span>[</span>12<span>]</span></a></sup>  This performance was attained by means of the highly optimized yet platform independent LIBRT ray-tracing engine in BRL-CAD and by using solid implicit <a href=\"/wiki/Constructive_solid_geometry\" title=\"Constructive solid geometry\">CSG</a> geometry on several shared memory parallel machines over a commodity network.  BRL-CAD's ray-tracer, including REMRT/RT tools, continue to be available and developed today as <a href=\"/wiki/Open_source\" title=\"Open source\">Open source</a> software.<sup id=\"cite_ref-13\" class=\"reference\"><a href=\"#cite_note-13\"><span>[</span>13<span>]</span></a></sup>\n</p><p>Since then, there have been considerable efforts and research towards implementing ray tracing in real time speeds for a variety of purposes on stand-alone desktop configurations.  These purposes include interactive 3D graphics applications such as <a href=\"/wiki/Demo_(computer_programming)\" title=\"Demo (computer programming)\">demoscene productions</a>, <a href=\"/wiki/Video_game\" title=\"Video game\">computer and video games</a>, and image rendering.  Some real-time software 3D engines based on ray tracing have been developed by hobbyist <a href=\"/wiki/Demoscene\" title=\"Demoscene\">demo programmers</a> since the late 1990s.<sup id=\"cite_ref-14\" class=\"reference\"><a href=\"#cite_note-14\"><span>[</span>14<span>]</span></a></sup>\n</p><p>The <a href=\"/wiki/OpenRT\" title=\"OpenRT\">OpenRT</a> project includes a highly optimized software core for ray tracing along with an <a href=\"/wiki/OpenGL\" title=\"OpenGL\">OpenGL</a>-like API in order to offer an alternative to the current <a href=\"/wiki/Rasterisation\" title=\"Rasterisation\">rasterisation</a> based approach for interactive 3D graphics.  <a href=\"/wiki/Ray_tracing_hardware\" title=\"Ray tracing hardware\">Ray tracing hardware</a>, such as the experimental <a href=\"/wiki/Ray_Processing_Unit\" title=\"Ray Processing Unit\" class=\"mw-redirect\">Ray Processing Unit</a> developed at the <a href=\"/wiki/Saarland_University\" title=\"Saarland University\">Saarland University</a>, has been designed to accelerate some of the computationally intensive operations of ray tracing.  On March 16, 2007, the University of Saarland revealed an implementation of a high-performance ray tracing engine that allowed computer games to be rendered via ray tracing without intensive resource usage.<sup id=\"cite_ref-15\" class=\"reference\"><a href=\"#cite_note-15\"><span>[</span>15<span>]</span></a></sup>\n</p><p>On June 12, 2008 Intel demonstrated a special version of <i><a href=\"/wiki/Enemy_Territory:_Quake_Wars\" title=\"Enemy Territory: Quake Wars\">Enemy Territory: Quake Wars</a></i>, titled <i><a href=\"/wiki/Quake_Wars:_Ray_Traced\" title=\"Quake Wars: Ray Traced\">Quake Wars: Ray Traced</a></i>, using ray tracing for rendering, running in basic HD (720p) resolution. ETQW operated at 14-29 frames per second.  The demonstration ran on a 16-core (4 socket, 4 core) Xeon Tigerton system running at 2.93&#160;GHz.<sup id=\"cite_ref-16\" class=\"reference\"><a href=\"#cite_note-16\"><span>[</span>16<span>]</span></a></sup>\n</p><p>At SIGGRAPH 2009, Nvidia announced <a href=\"/wiki/OptiX\" title=\"OptiX\">OptiX</a>, a free API for real-time ray tracing on Nvidia GPUs. The API exposes seven programmable entry points within the ray tracing pipeline, allowing for custom cameras, ray-primitive intersections, shaders, shadowing, etc. This flexibility enables bidirectional path tracing, Metropolis light transport, and many other rendering algorithms that cannot be implemented with tail recursion.<sup id=\"cite_ref-17\" class=\"reference\"><a href=\"#cite_note-17\"><span>[</span>17<span>]</span></a></sup> Nvidia has shipped over 350,000,000 OptiX capable GPUs as of April 2013. OptiX-based renderers are used in <a href=\"/wiki/Adobe_Systems\" title=\"Adobe Systems\">Adobe</a> <a href=\"/wiki/AfterEffects\" title=\"AfterEffects\" class=\"mw-redirect\">AfterEffects</a>, Bunkspeed Shot, <a href=\"/wiki/Autodesk_Maya\" title=\"Autodesk Maya\">Autodesk Maya</a>, <a href=\"/wiki/3ds_max\" title=\"3ds max\" class=\"mw-redirect\">3ds max</a>, and many other renderers.\n</p><p><a href=\"/wiki/Imagination_Technologies\" title=\"Imagination Technologies\">Imagination Technologies</a> offers a free <a href=\"/wiki/API\" title=\"API\" class=\"mw-redirect\">API</a> called <a href=\"/wiki/OpenRL\" title=\"OpenRL\">OpenRL</a> which accelerates <a href=\"/wiki/Tail_recursion\" title=\"Tail recursion\" class=\"mw-redirect\">tail recursive</a> ray tracing-based rendering algorithms and, together with their proprietary <a href=\"/wiki/Ray_tracing_hardware\" title=\"Ray tracing hardware\">ray tracing hardware</a>, works with <a href=\"/wiki/Autodesk_Maya\" title=\"Autodesk Maya\">Autodesk Maya</a> to provide what <a href=\"/wiki/3D_World\" title=\"3D World\">3D World</a> calls \"real-time raytracing to the everyday artist\".<sup id=\"cite_ref-18\" class=\"reference\"><a href=\"#cite_note-18\"><span>[</span>18<span>]</span></a></sup>\n</p>\n<h2><span class=\"mw-headline\" id=\"Computational_Complexity\">Computational Complexity</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=13\" title=\"Edit section: Computational Complexity\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Various complexity results have been proven for certain formulations of the ray tracing problem. In particular, if the decision version of the ray tracing problem is defined as follows<sup id=\"cite_ref-19\" class=\"reference\"><a href=\"#cite_note-19\"><span>[</span>19<span>]</span></a></sup> - given a light ray's initial position and direction and some fixed point, does the ray eventually reach that point, then the referenced paper proves the following results&#160;:-\n</p>\n<ul><li> Ray tracing in 3D optical systems with a finite set of reflective or refractive objects represented by a system of rational quadratic inequalities is undecidable.</li>\n<li> Ray tracing in 3D optical systems with a finite set of refractive objects represented by a system of rational linear inequalities is undecidable.</li>\n<li> Ray tracing in 3D optical systems with a finite set of rectangular reflective or refractive objects is undecidable.</li>\n<li> Ray tracing in 3D optical systems with a finite set of reflective or partially reflective objects represented by a system of linear inequalities, some of which can be irrational is undecidable.</li>\n<li> Ray tracing in 3D optical systems with a finite set of reflective or partially reflective objects represented by a system of rational linear inequalities is PSPACE-hard.</li>\n<li> For any dimension equal to or greater than 2, ray tracing with a finite set of parallel and perpendicular reflective surfaces represented by rational linear inequalities is in PSPACE.</li></ul>\n<h2><span class=\"mw-headline\" id=\"See_also\">See also</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=14\" title=\"Edit section: See also\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<div class=\"noprint portal tright\" style=\"border:solid #aaa 1px;margin:0.5em 0 0.5em 1em\">\n<table style=\"background:#f9f9f9;font-size:85%;line-height:110%;max-width:175px\">\n<tr style=\"vertical-align:middle\"><td style=\"text-align:center\"><a href=\"/wiki/File:5-cell.gif\" class=\"image\"><img alt=\"Portal icon\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d8/5-cell.gif/28px-5-cell.gif\" width=\"28\" height=\"28\" class=\"noviewer\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d8/5-cell.gif/42px-5-cell.gif 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/d8/5-cell.gif/56px-5-cell.gif 2x\" data-file-width=\"252\" data-file-height=\"252\" /></a></td><td style=\"padding:0 0.2em;vertical-align:middle;font-style:italic;font-weight:bold\"><a href=\"/wiki/Portal:Computer_graphics\" title=\"Portal:Computer graphics\">Computer graphics portal</a></td></tr></table></div>\n<ul><li> <a href=\"/wiki/Beam_tracing\" title=\"Beam tracing\">Beam tracing</a></li>\n<li> <a href=\"/wiki/Cone_tracing\" title=\"Cone tracing\">Cone tracing</a></li>\n<li> <a href=\"/wiki/Distributed_ray_tracing\" title=\"Distributed ray tracing\">Distributed ray tracing</a></li>\n<li> <a href=\"/wiki/Global_illumination\" title=\"Global illumination\">Global illumination</a></li>\n<li> <a href=\"/wiki/Gouraud_shading\" title=\"Gouraud shading\">Gouraud shading</a></li>\n<li> <a href=\"/wiki/List_of_ray_tracing_software\" title=\"List of ray tracing software\">List of ray tracing software</a></li>\n<li> <a href=\"/wiki/Parallel_computing\" title=\"Parallel computing\">Parallel computing</a></li>\n<li> <a href=\"/wiki/Phong_shading\" title=\"Phong shading\">Phong shading</a></li>\n<li> <a href=\"/wiki/Progressive_refinement\" title=\"Progressive refinement\">Progressive refinement</a></li>\n<li> <a href=\"/wiki/Rendering_(computer_graphics)\" title=\"Rendering (computer graphics)\">Rendering (computer graphics)</a></li>\n<li> <a href=\"/wiki/Shading\" title=\"Shading\">Shading</a></li>\n<li> <a href=\"/wiki/Specular_reflection\" title=\"Specular reflection\">Specular reflection</a></li></ul>\n<h2><span class=\"mw-headline\" id=\"References\">References</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=15\" title=\"Edit section: References\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<div class=\"reflist columns references-column-width\" style=\"-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em; list-style-type: decimal;\">\n<ol class=\"references\">\n<li id=\"cite_note-1\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-1\">^</a></b></span> <span class=\"reference-text\">Appel A. (1968) <i><a rel=\"nofollow\" class=\"external text\" href=\"http://graphics.stanford.edu/courses/Appel.pdf\">Some techniques for shading machine renderings of solids</a></i>.  AFIPS Conference Proc. 32 pp.37-45</span>\n</li>\n<li id=\"cite_note-2\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-2\">^</a></b></span> <span class=\"reference-text\">Whitted T. (1979) <i><a rel=\"nofollow\" class=\"external text\" href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.156.1534\">An improved illumination model for shaded display</a></i>.  Proceedings of the 6th annual conference on Computer graphics and interactive techniques</span>\n</li>\n<li id=\"cite_note-3\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-3\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation journal\">Tomas Nikodym (June 2010). <a rel=\"nofollow\" class=\"external text\" href=\"https://dip.felk.cvut.cz/browse/pdfcache/nikodtom_2010bach.pdf\">\"Ray Tracing Algorithm For Interactive Applications\"</a>. <i>Czech Technical University, FEE</i>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.atitle=Ray+Tracing+Algorithm+For+Interactive+Applications&amp;rft.aulast=Tomas+Nikodym&amp;rft.au=Tomas+Nikodym&amp;rft.date=June+2010&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fdip.felk.cvut.cz%2Fbrowse%2Fpdfcache%2Fnikodtom_2010bach.pdf&amp;rft.jtitle=Czech+Technical+University%2C+FEE&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-4\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-4\">^</a></b></span> <span class=\"reference-text\">J.-C. Nebel. A New Parallel Algorithm Provided by a Computation Time Model, Eurographics Workshop on Parallel Graphics and Visualisation, 24-25 September 1998, Rennes, France.</span>\n</li>\n<li id=\"cite_note-5\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-5\">^</a></b></span> <span class=\"reference-text\">A. Chalmers, T. Davis, and E. Reinhard. Practical parallel rendering, <a href=\"/wiki/Special:BookSources/1568811799\" class=\"internal mw-magiclink-isbn\">ISBN 1-56881-179-9</a>. AK Peters, Ltd., 2002.</span>\n</li>\n<li id=\"cite_note-6\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-6\">^</a></b></span> <span class=\"reference-text\"><a rel=\"nofollow\" class=\"external text\" href=\"http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter38.html\">GPU Gems 2, Chapter 38. High-Quality Global Illumination Rendering Using Rasterization, Addison-Wesley</a></span>\n</li>\n<li id=\"cite_note-7\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-7\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation journal\">Eric P. Lafortune and Yves D. Willems (December 1993). <a rel=\"nofollow\" class=\"external text\" href=\"http://www.graphics.cornell.edu/~eric/Portugal.html\">\"Bi-Directional Path Tracing\"</a>. <i>Proceedings of Compugraphics '93</i>: 145\u2013153.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.atitle=Bi-Directional+Path+Tracing&amp;rft.au=Eric+P.+Lafortune+and+Yves+D.+Willems&amp;rft.aulast=Eric+P.+Lafortune+and+Yves+D.+Willems&amp;rft.date=December+1993&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.graphics.cornell.edu%2F~eric%2FPortugal.html&amp;rft.jtitle=Proceedings+of+Compugraphics+%2793&amp;rft.pages=145-153&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-8\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-8\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\">P\u00e9ter Dornbach. <a rel=\"nofollow\" class=\"external text\" href=\"http://www.cescg.org/CESCG98/PDornbach/index.html\">\"Implementation of bidirectional ray tracing algorithm\"</a><span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2008-06-11</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.aulast=P%C3%A9ter+Dornbach&amp;rft.au=P%C3%A9ter+Dornbach&amp;rft.btitle=Implementation+of+bidirectional+ray+tracing+algorithm&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cescg.org%2FCESCG98%2FPDornbach%2Findex.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-9\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-9\">^</a></b></span> <span class=\"reference-text\"><a rel=\"nofollow\" class=\"external text\" href=\"http://graphics.ucsd.edu/~henrik/papers/photon_map/global_illumination_using_photon_maps_egwr96.pdf\">Global Illumination using Photon Maps</a></span>\n</li>\n<li id=\"cite_note-10\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-10\">^</a></b></span> <span class=\"reference-text\"><a rel=\"nofollow\" class=\"external text\" href=\"http://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/photon_mapping/PhotonMapping.html\">Photon Mapping - Zack Waters</a></span>\n</li>\n<li id=\"cite_note-11\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-11\">^</a></b></span> <span class=\"reference-text\"><a rel=\"nofollow\" class=\"external free\" href=\"http://graphics.stanford.edu/papers/metro/metro.pdf\">http://graphics.stanford.edu/papers/metro/metro.pdf</a></span>\n</li>\n<li id=\"cite_note-12\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-12\">^</a></b></span> <span class=\"reference-text\">See Proceedings of 4th Computer Graphics Workshop, Cambridge, MA, USA, October 1987. Usenix Association, 1987. pp 86\u201398.</span>\n</li>\n<li id=\"cite_note-13\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-13\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\"><a rel=\"nofollow\" class=\"external text\" href=\"http://brlcad.org/d/about\">\"About BRL-CAD\"</a><span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2009-07-28</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.btitle=About+BRL-CAD&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbrlcad.org%2Fd%2Fabout&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-14\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-14\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\">Piero Foscari. <a rel=\"nofollow\" class=\"external text\" href=\"http://www.acm.org/tog/resources/RTNews/demos/overview.htm\">\"The Realtime Raytracing Realm\"</a>. <i>ACM Transactions on Graphics</i><span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2007-09-17</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.atitle=The+Realtime+Raytracing+Realm&amp;rft.aulast=Piero+Foscari&amp;rft.au=Piero+Foscari&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.acm.org%2Ftog%2Fresources%2FRTNews%2Fdemos%2Foverview.htm&amp;rft.jtitle=ACM+Transactions+on+Graphics&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-15\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-15\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation news\">Mark Ward (March 16, 2007). <a rel=\"nofollow\" class=\"external text\" href=\"http://news.bbc.co.uk/1/hi/technology/6457951.stm\">\"Rays light up life-like graphics\"</a>. BBC News<span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2007-09-17</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.aulast=Mark+Ward&amp;rft.au=Mark+Ward&amp;rft.btitle=Rays+light+up+life-like+graphics&amp;rft.date=March+16%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fnews.bbc.co.uk%2F1%2Fhi%2Ftechnology%2F6457951.stm&amp;rft.pub=BBC+News&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-16\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-16\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\">Theo Valich (June 12, 2008). <a rel=\"nofollow\" class=\"external text\" href=\"http://www.tgdaily.com/html_tmp/content-view-37925-113.html\">\"Intel converts ET: Quake Wars to ray tracing\"</a>. TG Daily<span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2008-06-16</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.aulast=Theo+Valich&amp;rft.au=Theo+Valich&amp;rft.btitle=Intel+converts+ET%3A+Quake+Wars+to+ray+tracing&amp;rft.date=June+12%2C+2008&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.tgdaily.com%2Fhtml_tmp%2Fcontent-view-37925-113.html&amp;rft.pub=TG+Daily&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-17\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-17\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\">Nvidia (October 18, 2009). <a rel=\"nofollow\" class=\"external text\" href=\"http://www.nvidia.com/object/optix.html\">\"Nvidia OptiX\"</a>. Nvidia<span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2009-11-06</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.aulast=Nvidia&amp;rft.au=Nvidia&amp;rft.btitle=Nvidia+OptiX&amp;rft.date=October+18%2C+2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.nvidia.com%2Fobject%2Foptix.html&amp;rft.pub=Nvidia&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></span>\n</li>\n<li id=\"cite_note-18\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-18\">^</a></b></span> <span class=\"reference-text\"><span class=\"citation web\"><a rel=\"nofollow\" class=\"external text\" href=\"http://www.3dworldmag.com/2013/04/16/hardware-review-caustic-series2-r2500-ray-tracing-accelerator-card/\">\"3DWorld: Hardware review: Caustic Series2 R2500 ray-tracing accelerator card\"</a><span class=\"reference-accessdate\">. Retrieved <span class=\"nowrap\">2013-04-23</span></span>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ARay+tracing+%28graphics%29&amp;rft.btitle=3DWorld%3A+Hardware+review%3A+Caustic+Series2+R2500+ray-tracing+accelerator+card&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.3dworldmag.com%2F2013%2F04%2F16%2Fhardware-review-caustic-series2-r2500-ray-tracing-accelerator-card%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span>3D World, April 2013</span>\n</li>\n<li id=\"cite_note-19\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-19\">^</a></b></span> <span class=\"reference-text\">\"Computability and Complexity of Ray Tracing\". <a rel=\"nofollow\" class=\"external free\" href=\"https://www.cs.duke.edu/~reif/paper/tygar/raytracing.pdf\">https://www.cs.duke.edu/~reif/paper/tygar/raytracing.pdf</a></span>\n</li>\n</ol></div>\n<h2><span class=\"mw-headline\" id=\"External_links\">External links</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Ray_tracing_(graphics)&amp;action=edit&amp;section=16\" title=\"Edit section: External links\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<table class=\"mbox-small plainlinks\" style=\"border:1px solid #aaa;background-color:#f9f9f9\">\n<tr>\n<td class=\"mbox-image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png\" width=\"30\" height=\"40\" srcset=\"//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/45px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/59px-Commons-logo.svg.png 2x\" data-file-width=\"1024\" data-file-height=\"1376\" /></td>\n<td class=\"mbox-text plainlist\">Wikimedia Commons has media related to <i><b><a href=\"//commons.wikimedia.org/wiki/Category:Ray_tracing\" class=\"extiw\" title=\"commons:Category:Ray tracing\">Ray tracing</a></b></i>.</td></tr></table>\n<ul><li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.codermind.com/articles/Raytracer-in-C++-Introduction-What-is-ray-tracing.html\">What is ray tracing&#160;?</a></li>\n<li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.pcper.com/reviews/Graphics-Cards/Ray-Tracing-and-Gaming-Quake-4-Ray-Traced-Project\">Ray Tracing and Gaming - Quake 4: Ray Traced Project</a></li>\n<li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.pcper.com/reviews/Processors/Ray-Tracing-and-Gaming-One-Year-Later\">Ray tracing and Gaming - One Year Later</a></li>\n<li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.few.vu.nl/~kielmann/theses/avdploeg.pdf\">Interactive Ray Tracing: The replacement of rasterization?</a></li>\n<li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.youtube.com/watch?v=WV4qXzM641o\">The Compleat Angler (1978)</a></li>\n<li> <a rel=\"nofollow\" class=\"external text\" href=\"http://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing\">Writing a Simple Ray Tracer (scratchapixel)</a></li></ul>\n"}]}}}, "warnings": {"query": {"*": "Formatting of continuation data will be changing soon. To continue using the current formatting, use the 'rawcontinue' parameter. To begin using the new format, pass an empty string for 'continue' in the initial query."}}}