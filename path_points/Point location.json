{"query": {"pages": {"504494": {"lastrevid": 592383403, "pageid": 504494, "canonicalurl": "http://en.wikipedia.org/wiki/Point_location", "title": "Point location", "editurl": "http://en.wikipedia.org/w/index.php?title=Point_location&action=edit", "length": 14057, "contentmodel": "wikitext", "pagelanguage": "en", "touched": "2015-02-14T13:05:20Z", "ns": 0, "fullurl": "http://en.wikipedia.org/wiki/Point_location", "revisions": [{"*": "<table class=\"metadata plainlinks ambox ambox-style ambox-No_footnotes\" role=\"presentation\"><tr><td class=\"mbox-image\"><div style=\"width:52px\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/40px-Text_document_with_red_question_mark.svg.png\" width=\"40\" height=\"40\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/60px-Text_document_with_red_question_mark.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/80px-Text_document_with_red_question_mark.svg.png 2x\" data-file-width=\"48\" data-file-height=\"48\" /></div></td><td class=\"mbox-text\"><span class=\"mbox-text-span\">This article includes a <a href=\"/wiki/Wikipedia:Citing_sources\" title=\"Wikipedia:Citing sources\">list of references</a>, related reading or <a href=\"/wiki/Wikipedia:External_links\" title=\"Wikipedia:External links\">external links</a>, but <b>its sources remain unclear because it lacks <a href=\"/wiki/Wikipedia:Citing_sources#Inline_citations\" title=\"Wikipedia:Citing sources\">inline citations</a></b>.<span class=\"hide-when-compact\"> Please <a href=\"/wiki/Wikipedia:WikiProject_Fact_and_Reference_Check\" title=\"Wikipedia:WikiProject Fact and Reference Check\">improve</a> this article by introducing more precise citations.</span>  <small><i>(June 2013)</i></small><span class=\"hide-when-compact\"></span></span></td></tr></table>\n<p>The <b>point location</b> problem is a fundamental topic of <a href=\"/wiki/Computational_geometry\" title=\"Computational geometry\">computational geometry</a>. It finds applications in areas that deal with processing geometrical data: <a href=\"/wiki/Computer_graphics\" title=\"Computer graphics\">computer graphics</a>, <a href=\"/wiki/Geographic_information_system\" title=\"Geographic information system\">geographic information systems</a> (GIS), <a href=\"/wiki/Motion_planning\" title=\"Motion planning\">motion planning</a>, and <a href=\"/wiki/Computer_aided_design\" title=\"Computer aided design\" class=\"mw-redirect\">computer aided design</a> (CAD).\n</p><p>In its most general form, the problem is, given a partition of the space into disjoint regions, determine the region where a query point lies. As an example application, each time you click a mouse to follow a link in a <a href=\"/wiki/Web_browser\" title=\"Web browser\">web browser</a>, this problem must be solved in order to determine which area of the computer screen is under the mouse pointer. A simple special case is the <a href=\"/wiki/Point_in_polygon\" title=\"Point in polygon\">point in polygon</a> problem. In this case, we need to determine whether the point is inside, outside, or on the boundary of a single polygon.\n</p><p>In many applications, we need to determine the location of several different points with respect to the same partition of the space. To solve this problem efficiently, it is useful to build a <a href=\"/wiki/Data_structure\" title=\"Data structure\">data structure</a> that, given a query point, quickly determines which region contains the query point.\n</p>\n<div id=\"toc\" class=\"toc\"><div id=\"toctitle\"><h2>Contents</h2></div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Planar_case\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Planar case</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-2\"><a href=\"#Slab_decomposition\"><span class=\"tocnumber\">1.1</span> <span class=\"toctext\">Slab decomposition</span></a></li>\n<li class=\"toclevel-2 tocsection-3\"><a href=\"#Monotone_subdivisions\"><span class=\"tocnumber\">1.2</span> <span class=\"toctext\">Monotone subdivisions</span></a></li>\n<li class=\"toclevel-2 tocsection-4\"><a href=\"#Triangulation_refinement\"><span class=\"tocnumber\">1.3</span> <span class=\"toctext\">Triangulation refinement</span></a></li>\n<li class=\"toclevel-2 tocsection-5\"><a href=\"#Trapezoidal_decomposition\"><span class=\"tocnumber\">1.4</span> <span class=\"toctext\">Trapezoidal decomposition</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-6\"><a href=\"#Higher_dimensions\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Higher dimensions</span></a></li>\n<li class=\"toclevel-1 tocsection-7\"><a href=\"#References\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">References</span></a></li>\n<li class=\"toclevel-1 tocsection-8\"><a href=\"#External_links\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">External links</span></a></li>\n</ul>\n</div>\n\n<h2><span class=\"mw-headline\" id=\"Planar_case\">Planar case</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=1\" title=\"Edit section: Planar case\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Point_location1.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Point_location1.png/250px-Point_location1.png\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Point_location1.png/375px-Point_location1.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Point_location1.png/500px-Point_location1.png 2x\" data-file-width=\"600\" data-file-height=\"600\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Point_location1.png\" class=\"internal\" title=\"Enlarge\"></a></div>A planar subdivision inside a <a href=\"/wiki/Bounding_box\" title=\"Bounding box\" class=\"mw-redirect\">bounding box</a></div></div></div>\n<p>In the planar case, we are given a <a href=\"/wiki/Planar_subdivision\" title=\"Planar subdivision\" class=\"mw-redirect\">planar subdivision</a> <i>S</i>, formed by multiple <a href=\"/wiki/Polygon\" title=\"Polygon\">polygons</a> called faces, and need to determine which face contains a query point. A <a href=\"/wiki/Brute_force_search\" title=\"Brute force search\" class=\"mw-redirect\">brute force search</a> of each face using the <a href=\"/wiki/Point-in-polygon\" title=\"Point-in-polygon\" class=\"mw-redirect\">point-in-polygon</a> algorithm is possible, but usually not feasible for subdivisions of high complexity. Several different approaches lead to optimal data structures, with <a href=\"/wiki/Big_O_notation\" title=\"Big O notation\">O</a>(<i>n</i>) storage space and O(log <i>n</i>) query time, where <i>n</i> is the total number of vertices in <i>S</i>. For simplicity, we assume that the planar subdivision is contained inside a square bounding box.\n</p>\n<h3><span class=\"mw-headline\" id=\"Slab_decomposition\">Slab decomposition</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=2\" title=\"Edit section: Slab decomposition\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Point_location2.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Point_location2.png/250px-Point_location2.png\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Point_location2.png/375px-Point_location2.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Point_location2.png/500px-Point_location2.png 2x\" data-file-width=\"600\" data-file-height=\"600\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Point_location2.png\" class=\"internal\" title=\"Enlarge\"></a></div>A planar subdivision divided into slabs.</div></div></div>\n<p>The simplest and earliest data structure to achieve O(log <i>n</i>) time was discovered by <a href=\"/wiki/David_Dobkin_(professor)\" title=\"David Dobkin (professor)\" class=\"mw-redirect\">Dobkin</a> and <a href=\"/wiki/Richard_J._Lipton\" title=\"Richard J. Lipton\">Lipton</a> in 1976. It is based on subdividing <i>S</i> using vertical lines that pass through each vertex in <i>S</i>. The region between two consecutive vertical lines is called a slab. Notice that each slab is divided by non-intersecting line segments that completely cross the slab from left to right. The region between two consecutive segments inside a slab corresponds to a unique face of <i>S</i>. Therefore, we reduce our point location problem to two simpler problems:\n</p>\n<ol><li> Given a subdivision of the plane into vertical slabs, determine which slab contains a given point.</li>\n<li> Given a slab subdivided into regions by non-intersecting segments that completely cross the slab from left to right, determine which region contains a given point.</li></ol>\n<p>The first problem can be solved by <a href=\"/wiki/Binary_search\" title=\"Binary search\" class=\"mw-redirect\">binary search</a> on the <i>x</i> coordinate of the vertical lines in O(log <i>n</i>) time. The second problem can also be solved in O(log <i>n</i>) time by binary search. To see how, notice that, as the segments do not intersect and completely cross the slab, the segments can be sorted vertically inside each slab.\n</p><p>While this algorithm allows point location in logarithmic time and is easy to implement, the space required to build the slabs and the regions contained within the slabs can be as high as O(<i>n</i>\u00b2), since each slab can cross a significant fraction of the segments.\n</p><p>Several authors noticed that the segments that cross two adjacent slabs are mostly the same. Therefore, the size of the data structure could potentially be reduced by applying some kind of compression, where only the difference between two adjacent slabs is stored. Sarnak and Tarjan managed to use this idea to reduce the storage space to O(<i>n</i>), while maintaining the O(log <i>n</i>) query time. Unfortunately, the data structure becomes highly complex.\n</p>\n<h3><span class=\"mw-headline\" id=\"Monotone_subdivisions\">Monotone subdivisions</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=3\" title=\"Edit section: Monotone subdivisions\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Point_location3.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/37/Point_location3.png/250px-Point_location3.png\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/37/Point_location3.png/375px-Point_location3.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/37/Point_location3.png/500px-Point_location3.png 2x\" data-file-width=\"600\" data-file-height=\"600\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Point_location3.png\" class=\"internal\" title=\"Enlarge\"></a></div>A monotone planar subdivision with some monotone chains highlighted.</div></div></div>\n<p>A (vertical) monotone chain is a <a href=\"/wiki/Path_(graph_theory)\" title=\"Path (graph theory)\">path</a> such that the <i>y</i>-coordinate never increases along the path. A <a href=\"/wiki/Simple_polygon\" title=\"Simple polygon\">simple polygon</a> is (vertical) monotone if it is formed by two monotone chains, with the first and last vertices in common. It is possible to add some edges to a planar subdivision, in order to make all faces monotone, obtaining what is called a monotone subdivision. This process does not add any vertices to the subdivision (therefore, the size remains O(<i>n</i>)), and can be performed in O(<i>n</i> log <i>n</i>) time by <a href=\"/wiki/Plane_sweep\" title=\"Plane sweep\" class=\"mw-redirect\">plane sweep</a> (it can also be performed in linear time, using <a href=\"/wiki/Polygon_triangulation\" title=\"Polygon triangulation\">polygon triangulation</a>). Therefore, there is no loss of generality, if we restrict our data structure to the case of monotone subdivisions, as we do in this section.\n</p><p>The weakness of the slab decomposition is that the vertical lines create additional segments in the decomposition, making it difficult to achieve O(<i>n</i>) storage space. <a href=\"/wiki/Herbert_Edelsbrunner\" title=\"Herbert Edelsbrunner\">Edelsbrunner</a>, <a href=\"/wiki/Leonidas_J._Guibas\" title=\"Leonidas J. Guibas\">Guibas</a>, and <a href=\"/wiki/Jorge_Stolfi\" title=\"Jorge Stolfi\">Stolfi</a> discovered an optimal data structure that only uses the edges in a monotone subdivision. The idea is to use vertical monotone chains, instead of using vertical lines to partition the subdivision.\n</p><p>Converting this general idea to an actual efficient data structure is not a simple task. First, we need to be able to compute a monotone chain that divides the subdivision into two halves of similar sizes. Second, since some edges may be contained in several monotone chains, we need to be careful to guarantee that the storage space is O(n). Third, testing whether a point is on the left or the right side of a monotone subdivision takes O(<i>n</i>) time if performed naively.\n</p><p>Details on how to solve the first two issues are beyond the scope of this article. We briefly mention how to address the third issue. Using binary search, we can test whether a point is to the left or right of a monotone chain in O(log <i>n</i>) time. As we need to perform another nested binary search through O(log <i>n</i>) chains to actually determine the point location, the query time is O(log\u00b2 n). To achieve O(log <i>n</i>) query time, we need to use <a href=\"/wiki/Fractional_cascading\" title=\"Fractional cascading\">fractional cascading</a>, keeping pointers between the edges of different monotone chains.\n</p>\n<h3><span class=\"mw-headline\" id=\"Triangulation_refinement\">Triangulation refinement</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=4\" title=\"Edit section: Triangulation refinement\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Point_location4.gif\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/en/thumb/9/96/Point_location4.gif/250px-Point_location4.gif\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/en/thumb/9/96/Point_location4.gif/375px-Point_location4.gif 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/96/Point_location4.gif/500px-Point_location4.gif 2x\" data-file-width=\"600\" data-file-height=\"600\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Point_location4.gif\" class=\"internal\" title=\"Enlarge\"></a></div>Successive steps of triangulation refinement.</div></div></div>\n<p>A polygon with <i>m</i> vertices can be partitioned into <i>m</i>-2 triangles. There are numerous algorithms to <a href=\"/wiki/Polygon_triangulation\" title=\"Polygon triangulation\">triangulate a polygon</a> efficiently, the fastest having O(<i>n</i>) worst case time. Therefore, we can decompose each polygon of our subdivision in triangles, and restrict our data structure to the case of subdivisions formed exclusively by triangles. Kirkpatrick gives a data structure for point location in triangulated subdivisions with O(<i>n</i>) storage space and O(log <i>n</i>) query time.\n</p><p>The general idea is to build a hierarchy of triangles. To perform a query, we start by finding the top-level triangle that contains the query point. Since the number of top-level triangles is bounded by a constant, this operation can be performed in O(1) time. Each triangle has pointers to the triangles it intersects in the next level of the hierarchy, and the number of pointers is also bounded by a constant. We proceed with the query by finding which triangle contains the query point level by level.\n</p><p>The data structure is built in the opposite order, that is, bottom-up. We start with the triangulated subdivision, and choose an <a href=\"/wiki/Independent_set_(graph_theory)\" title=\"Independent set (graph theory)\">independent set</a> of vertices to be removed. After removing the vertices, we retriangulate the subdivision. Because the subdivision is formed by triangles, a greedy algorithm can find an independent set that contains a constant fraction of the vertices. Therefore, the number of removal steps is O(log <i>n</i>).\n</p>\n<h3><span class=\"mw-headline\" id=\"Trapezoidal_decomposition\">Trapezoidal decomposition</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=5\" title=\"Edit section: Trapezoidal decomposition\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<div class=\"thumb tright\"><div class=\"thumbinner\" style=\"width:252px;\"><a href=\"/wiki/File:Trapezoidal_decomposition.png\" class=\"image\"><img alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Trapezoidal_decomposition.png/250px-Trapezoidal_decomposition.png\" width=\"250\" height=\"250\" class=\"thumbimage\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Trapezoidal_decomposition.png/375px-Trapezoidal_decomposition.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/43/Trapezoidal_decomposition.png/500px-Trapezoidal_decomposition.png 2x\" data-file-width=\"600\" data-file-height=\"600\" /></a>  <div class=\"thumbcaption\"><div class=\"magnify\"><a href=\"/wiki/File:Trapezoidal_decomposition.png\" class=\"internal\" title=\"Enlarge\"></a></div>A trapezoidal decomposition.</div></div></div>\n<p>A <a href=\"/wiki/Randomized_algorithm\" title=\"Randomized algorithm\">randomized</a> approach to this problem, and probably the most practical one, is based on <a href=\"/w/index.php?title=Trapezoidal_decomposition&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Trapezoidal decomposition (page does not exist)\">trapezoidal decomposition</a>, or trapezoidal map. A trapezoidal decomposition is obtained by shooting vertical bullets going both up and down from each vertex in the original subdivision. The bullets stop when they hit an edge, and form a new edge in the subdivision. This way, we obtain a subset of the slab decomposition, with only O(<i>n</i>) edges and vertices, since we only add two edges and two vertices for each vertex in the original subdivision.\n</p><p>It is not easy to see how to use a trapezoidal decomposition for point location, since a binary search similar to the one used in the slab decomposition can no longer be performed. Instead, we need to answer a query in the same fashion as the triangulation refinement approach, but the data structure is constructed top-down. Initially, we build a trapezoidal decomposition containing only the bounding box, and no internal vertex. Then, we add the segments from the subdivision, one by one, in random order, refining the trapezoidal decomposition. Using <a href=\"/w/index.php?title=Backwards_analysis&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Backwards analysis (page does not exist)\">backwards analysis</a>, we can show that the expected number of trapezoids created for each insertion is bounded by a constant.\n</p><p>We build a <a href=\"/wiki/Directed_acyclic_graph\" title=\"Directed acyclic graph\">directed acyclic graph</a>, where the vertices are the trapezoids that existed at some point in the refinement, and the directed edges connect the trapezoids obtained by subdivision. The expected depth of a search in this digraph, starting from the vertex corresponding to the bounding box, is O(log <i>n</i>).\n</p>\n<h2><span class=\"mw-headline\" id=\"Higher_dimensions\">Higher dimensions</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=6\" title=\"Edit section: Higher dimensions\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>There are no known general point location data structures with linear space and logarithmic query time for dimensions greater than 2. Therefore, we need to sacrifice either query time, or storage space, or restrict ourselves to some less general type of subdivision.\n</p><p>In three-dimensional space, it is possible to answer point location queries in O(log\u00b2 <i>n</i>) using O(<i>n</i> log <i>n</i>) space. The general idea is to maintain several planar point location data structures, corresponding to the intersection of the subdivision with <i>n</i> parallel planes that contain each subdivision vertex. A naive use of this idea would increase the storage space to O(<i>n</i>\u00b2). In the same fashion as in the slab decomposition, the similarity between consecutive data structures can be exploited in order to reduce the storage space to O(<i>n</i> log <i>n</i>), but the query time increases to O(log\u00b2 <i>n</i>).\n</p><p>In <i>d</i>-dimensional space, point location can be solved by recursively projecting the faces into a (<i>d</i>-1)-dimensional space. While the query time is O(log <i>n</i>), the storage space can be as high as <img class=\"mwe-math-fallback-image-inline tex\" alt=\"O(n^{2^d})\" src=\"//upload.wikimedia.org/math/5/5/2/552502d9dc7434bbe492e6ab30aaf767.png\" />. The high complexity of the <i>d</i>-dimensional data structures led to the study of special types of subdivision.\n</p><p>One important example is the case of <a href=\"/wiki/Arrangement_of_hyperplanes\" title=\"Arrangement of hyperplanes\">arrangements of hyperplanes</a>. An arrangement of <i>n</i> hyperplanes defines O(<i>n<sup>d</sup></i>) cells, but point location can be performed in O(log <i>n</i>) time with O(<i>n<sup>d</sup></i>) space by using <a href=\"/wiki/Bernard_Chazelle\" title=\"Bernard Chazelle\">Chazelle</a>'s hierarchical <a href=\"/w/index.php?title=Cutting_(geometry)&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Cutting (geometry) (page does not exist)\">cuttings</a>.\n</p><p>Another special type of subdivision is called rectilinear (or orthogonal) subdivision. In a rectilinear subdivision, all edges are parallel to one of the <i>d</i> orthogonal axis. In this case, point location can be answered in O(log<sup><i>d</i>-1</sup> <i>n</i>) time with O(<i>n</i>) space.\n</p>\n<h2><span class=\"mw-headline\" id=\"References\">References</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=7\" title=\"Edit section: References\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<ul><li> <span class=\"citation book\">de Berg, Mark; van Kreveld, Marc; <a href=\"/wiki/Mark_Overmars\" title=\"Mark Overmars\">Overmars, Mark</a>; Schwarzkopf, Otfried (2000). \"Chapter 6: Point location\". <i>Computational Geometry</i> (2nd revised ed.). <a href=\"/wiki/Springer-Verlag\" title=\"Springer-Verlag\" class=\"mw-redirect\">Springer-Verlag</a>. pp.&#160;121\u2013146. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a>&#160;<a href=\"/wiki/Special:BookSources/3-540-65620-0\" title=\"Special:BookSources/3-540-65620-0\">3-540-65620-0</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Chapter+6%3A+Point+location&amp;rft.au=de+Berg%2C+Mark&amp;rft.aufirst=Mark&amp;rft.aulast=de+Berg&amp;rft.au=Overmars%2C+Mark&amp;rft.au=Schwarzkopf%2C+Otfried&amp;rft.au=van+Kreveld%2C+Marc&amp;rft.btitle=Computational+Geometry&amp;rft.date=2000&amp;rft.edition=2nd+revised&amp;rft.genre=bookitem&amp;rft.isbn=3-540-65620-0&amp;rft.pages=121-146&amp;rft.pub=Springer-Verlag&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li>\n<li><span class=\"citation journal\"><a href=\"/wiki/David_Dobkin_(professor)\" title=\"David Dobkin (professor)\" class=\"mw-redirect\">Dobkin, David</a>; <a href=\"/wiki/Richard_J._Lipton\" title=\"Richard J. Lipton\">Lipton, Richard J.</a> (1976). \"Multidimensional searching problems\". <i><a href=\"/wiki/SIAM_Journal_on_Computing\" title=\"SIAM Journal on Computing\">SIAM Journal on Computing</a></i> <b>5</b> (2): 181\u2013186. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a rel=\"nofollow\" class=\"external text\" href=\"//dx.doi.org/10.1137%2F0205015\">10.1137/0205015</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Multidimensional+searching+problems&amp;rft.au=Dobkin%2C+David&amp;rft.aufirst=David&amp;rft.aulast=Dobkin&amp;rft.au=Lipton%2C+Richard+J.&amp;rft.date=1976&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1137%2F0205015&amp;rft.issue=2&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.pages=181-186&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=5\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li>\n<li> <span class=\"citation book\">Snoeyink, Jack (2004). \"Chapter 34: \"Point Location\".  In <a href=\"/wiki/Jacob_E._Goodman\" title=\"Jacob E. Goodman\">Goodman, Jacob E.</a>; <a href=\"/wiki/Joseph_O%27Rourke_(professor)\" title=\"Joseph O&#39;Rourke (professor)\">O'Rourke, Joseph</a>. <i>Handbook of Discrete and Computational Geometry</i> (2nd ed.). Chapman &amp; Hall/CRC. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a>&#160;<a href=\"/wiki/Special:BookSources/1-58488-301-4\" title=\"Special:BookSources/1-58488-301-4\">1-58488-301-4</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Chapter+34%3A+%22Point+Location&amp;rft.aufirst=Jack&amp;rft.aulast=Snoeyink&amp;rft.au=Snoeyink%2C+Jack&amp;rft.btitle=Handbook+of+Discrete+and+Computational+Geometry&amp;rft.date=2004&amp;rft.edition=2nd&amp;rft.genre=bookitem&amp;rft.isbn=1-58488-301-4&amp;rft.pub=Chapman+%26+Hall%2FCRC&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li>\n<li> <span class=\"citation journal\">Sarnak, Neil; <a href=\"/wiki/Robert_Tarjan\" title=\"Robert Tarjan\">Tarjan, Robert E.</a> (1986). \"Planar point location using persistent search trees\". <i><a href=\"/wiki/Communications_of_the_ACM\" title=\"Communications of the ACM\">Communications of the ACM</a></i> <b>29</b> (7): 669\u2013679. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a rel=\"nofollow\" class=\"external text\" href=\"//dx.doi.org/10.1145%2F6138.6151\">10.1145/6138.6151</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Planar+point+location+using+persistent+search+trees&amp;rft.aufirst=Neil&amp;rft.aulast=Sarnak&amp;rft.au=Sarnak%2C+Neil&amp;rft.au=Tarjan%2C+Robert+E.&amp;rft.date=1986&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1145%2F6138.6151&amp;rft.issue=7&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.pages=669-679&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=29\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li>\n<li> <span class=\"citation journal\"><a href=\"/wiki/Herbert_Edelsbrunner\" title=\"Herbert Edelsbrunner\">Edelsbrunner, Herbert</a>; <a href=\"/wiki/Leonidas_J._Guibas\" title=\"Leonidas J. Guibas\">Guibas, Leonidas J.</a>; <a href=\"/wiki/Jorge_Stolfi\" title=\"Jorge Stolfi\">Stolfi, Jorge</a> (1986). \"Optimal point location in a monotone subdivision\". <i><a href=\"/wiki/SIAM_Journal_on_Computing\" title=\"SIAM Journal on Computing\">SIAM Journal on Computing</a></i> <b>15</b> (2): 317\u2013340. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a rel=\"nofollow\" class=\"external text\" href=\"//dx.doi.org/10.1137%2F0215023\">10.1137/0215023</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Optimal+point+location+in+a+monotone+subdivision&amp;rft.au=Edelsbrunner%2C+Herbert&amp;rft.aufirst=Herbert&amp;rft.au=Guibas%2C+Leonidas+J.&amp;rft.aulast=Edelsbrunner&amp;rft.au=Stolfi%2C+Jorge&amp;rft.date=1986&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1137%2F0215023&amp;rft.issue=2&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.pages=317-340&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=15\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li>\n<li> <span class=\"citation journal\"><a href=\"/wiki/David_G._Kirkpatrick\" title=\"David G. Kirkpatrick\">Kirkpatrick, David G.</a> (1983). \"Optimal search in planar subdivisions\". <i><a href=\"/wiki/SIAM_Journal_on_Computing\" title=\"SIAM Journal on Computing\">SIAM Journal on Computing</a></i> <b>12</b> (1): 28\u201335. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a rel=\"nofollow\" class=\"external text\" href=\"//dx.doi.org/10.1137%2F0212002\">10.1137/0212002</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APoint+location&amp;rft.atitle=Optimal+search+in+planar+subdivisions&amp;rft.aufirst=David+G.&amp;rft.au=Kirkpatrick%2C+David+G.&amp;rft.aulast=Kirkpatrick&amp;rft.date=1983&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1137%2F0212002&amp;rft.issue=1&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.pages=28-35&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=12\" class=\"Z3988\"><span style=\"display:none;\">&#160;</span></span></li></ul>\n<h2><span class=\"mw-headline\" id=\"External_links\">External links</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Point_location&amp;action=edit&amp;section=8\" title=\"Edit section: External links\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<ul><li><a rel=\"nofollow\" class=\"external text\" href=\"http://www.cs.sunysb.edu/~algorith/files/point-location.shtml\">Point-Location Source Repository</a> at Stony Brook University</li>\n<li><a rel=\"nofollow\" class=\"external text\" href=\"http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2/Chapter_main.html#Subsection_31.3.1\">Point-Location Queries</a> in <a href=\"/wiki/CGAL\" title=\"CGAL\">CGAL</a>, the Computational Geometry Algorithms Library</li></ul>\n"}]}}}, "warnings": {"query": {"*": "Formatting of continuation data will be changing soon. To continue using the current formatting, use the 'rawcontinue' parameter. To begin using the new format, pass an empty string for 'continue' in the initial query."}}}